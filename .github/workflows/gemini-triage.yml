# üè∑Ô∏è Gemini Auto-Triage Workflow
#
# Automatically analyzes and labels issues when they are opened or reopened.
# Uses Google Gemini AI to categorize issues by type, area, and priority.
#
# Documentation: .github/GEMINI_WORKFLOWS.md

name: "üè∑Ô∏è Gemini Triage (Label Issues)"

on:
  issues:
    types: [opened, reopened]

permissions:
  issues: write
  contents: read

concurrency:
  group: gemini-triage-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  triage:
    # Skip if issue was created by a bot
    if: github.event.sender.type != 'Bot'
    runs-on: ubuntu-latest
    timeout-minutes: 7

    steps:
      - name: Run Gemini (produce labels JSON)
        id: gemini
        uses: google-github-actions/run-gemini-cli@v0.1.20
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          gemini_model: ${{ vars.GEMINI_MODEL }}
          workflow_name: gemini-triage
          upload_artifacts: false
          prompt: |
            You are an intelligent issue triage assistant for a GitHub repository.
            Analyze the issue and suggest appropriate labels.

            **Output Format (JSON only):**
            ```json
            {"labels":["type:bug","area:android","priority:medium"]}
            ```

            **Label Guidelines:**

            **Type Labels** (choose ONE):
            - `type:bug` - Something is broken or not working as expected
            - `type:feature` - New functionality request
            - `type:enhancement` - Improvement to existing feature
            - `type:chore` - Maintenance, dependencies, refactoring
            - `type:question` - General question or discussion
            - `type:documentation` - Documentation related

            **Area Labels** (choose ONE or MORE if applicable):
            - `area:android` - Android platform specific
            - `area:ui` - User interface, Compose, Material Design
            - `area:media` - Video/audio playback, ExoPlayer
            - `area:network` - API calls, Retrofit, networking
            - `area:auth` - Authentication, login, security
            - `area:build` - Gradle, build system, CI/CD
            - `area:docs` - Documentation files
            - `area:testing` - Tests, test infrastructure

            **Priority Labels** (choose ONE):
            - `priority:critical` - Crashes, data loss, security issues
            - `priority:high` - Major functionality broken
            - `priority:medium` - Normal bugs or features
            - `priority:low` - Minor issues, nice-to-have

            **RULES:**
            - Output ONLY valid JSON with the exact schema shown
            - NO markdown code fences (```)
            - NO explanatory text
            - If uncertain, use fewer labels rather than guessing
            - Minimum 2 labels, maximum 5 labels

            **Issue Title:** ${{ github.event.issue.title }}

            **Issue Body:**
            ${{ github.event.issue.body }}

      - name: Parse + apply labels
        uses: actions/github-script@v7
        env:
          GEMINI_JSON: ${{ steps.gemini.outputs.summary }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.issue.number;

            let raw = (process.env.GEMINI_JSON || '').trim();
            if (!raw) {
              core.warning('Gemini returned empty output; skipping labels.');
              return;
            }

            // Strip markdown code fences if present (```json ... ``` or ``` ... ```)
            raw = raw.replace(/^```(?:json)?\s*/g, '').replace(/```$/g, '').trim();

            let data;
            try { data = JSON.parse(raw); }
            catch (e) {
              core.warning('Gemini output was not valid JSON:\n' + raw);
              return;
            }

            const labels = Array.isArray(data.labels) ? data.labels.filter(Boolean) : [];
            if (!labels.length) {
              core.info('No labels suggested.');
              return;
            }

            // Apply labels (pre-created labels are used)
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number, labels });
              core.info(`‚úÖ Applied labels: ${labels.join(', ')}`);
            } catch (e) {
              core.warning(`Failed to apply some labels: ${e.message}`);
              core.warning(`Suggested labels were: ${labels.join(', ')}`);
            }
